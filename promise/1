/*
 Promise
*/

function 非同期処理() {         // Promiseを返す関数＝非同期関数
    return Promise.resolve(1)
}

function 同期処理() {
    return 1
}

function main() {
    console.log(1 + 同期処理()) // 2


    // Promiseの結果の処理はthenが必要
    console.log(非同期処理().then(value => console.log(1 + value))) // 2

    //非同期処理().then(value => console.log(1 + value)) // 2
}

main()

/************************************************/
console.log("タイマー呼び出し前");
setTimeout(() => {
  console.log("時間が来た");
  }, 1000);
  console.log("タイマー呼び出し後");
  /*
    タイマー呼び出し前
    タイマー呼び出し後 // 上の行と同時に表示
    時間が来た        // 1秒後に表示
  */

/************************************************/
//Promiseとは
//非同期処理を「操作」するもの
//成功時の処理、失敗時の処理を明示的に書ける。

/************************************************/
// Promiseを返す関数
//
function asyncFunction(): Promise<string> {
    return new Promise(function (resolve, reject) {
        setTimeout(function() {
         resolve('Async Hello World');
             })
     })
}

asyncFunction().then(function (val) {
         console.log(val); // Async Hello world
});

/************************************************/
// Promiseを返す関数2  excuter分離
//
namespace te1 {
function excuter (resolve, reject) {
      setTimeout(
             function() {
                resolve('Async Hello World 2');
             }
      );
}

function asyncFunction2(): Promise<string> {
    return new Promise(excuter);
}

asyncFunction2().then(function (val) {
         console.log(val); // Async Hello world 2
});
}
/************************************************/
// Promiseを返す関数3  excuter分離   連鎖
//

namespace te2 {

function asyncFunction1(): Promise<string> {
    return new Promise(function (resolve, reject) {
        setTimeout(function() {
              resolve('Async Hello World');
                  })
     })
}

function asyncFunction2(): Promise<string> {
     return new Promise(function (resolve) {
         asyncFunction1().then(function (val) {
                                  resolve(val+'nyaan');
                       })
     })
}

asyncFunction2().then(
                 function (val) {
                         console.log(val); // => Async Hello Worldnyaan
                 }
);

}
/************************************************/
namespace te3 {

let fn1 = ()=>console.log('hello world1');
let fn2 = ()=>console.log('hello world2');
let fn3 = ()=>console.log('hello world3');

const test:Promise<void> = Promise.resolve(fn1());

test.then(fn2).then(fn3);


}
/************************************************/
// https://www.te-nu.com/entry/2018/03/21/170741
/*
namespace promis_test {
const anyProcessing = (): boolean => {
    // 何かの処理を行っていると仮定、５割の確率でコケる（falseを返す）
        return Math.random() >= 0.5;
       }

const test_promise = new Promise(
       (resolve: () => void, reject: () => void) => {
                if(anyProcessing()) {
                           resolve();
                 }
                 reject();
              }
       )

test_promise.then(() => {
           console.log("処理に成功しました");
            }).catch(() => {
           console.log("処理に失敗しました");
 });
};
*/
/************************************************/

/*
console.log("Promiseを使う");
//https://www.gesource.jp/weblog/?p=7663

// Promise<T>のTはresolveの引数の型
// Promiseのコンストラクタは、関数を引数に取ります。
//  引数の関数は、resolveとrejectを引数に取り、戻り値はありません。
//  resolveとrejectはどちらも関数です。
//  引数の関数の中で、非同期処理を実行します。
//  処理が成功したら、戻り値を引数にしてresolve()を呼びます。
//  失敗したときは、エラーの内容を引数にしてreject()を呼びます。

const p1 = new Promise<string>(
     (resolve: (value?: string) => void, reject: (reason?: any) => void) => {
    // 非同期の処理
    // 成功したときは戻り値を引数にしてresolveを呼ぶ
    // 失敗したときは戻り値を引数にしてrejectを呼ぶ
    setTimeout(() => {
        resolve("OK");  // 成功したときの戻り値
    }, 1000);
}).then(
    // Promiseが成功したとき
    (value: string) => { // 引数valueの型はProcese<T>のT型
        console.log(value);
    }
).catch(
    // Promiseが失敗したとき
    (reason: any) => {
        console.log(reason);
    }
);
*/
